<ol>
    <li>Better canvas moving, less responsive/fast</li>
    <li>Handle object outside of canvas</li>
    <li>Persist the new visible layout with a button</li>
    <li>Load in layout from file</li>
</ol>

<style>
    body {
        margin: 0px;
        height: 100%;
        font-family: monospace;
        font-size: 18px;
        overflow: hidden;
    }
    #container {
        width: 100%;
        display: flex;
        flex-direction: row;
    }
    #stage {
        width: 300px;
        height: 100%;
        background-color: #eee8d5;
        overflow-x: scroll;
        padding: 20px;
        border: 2px dashed;
    }
    #canvas {
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #fdf6e3;
    }
</style>

<div id="container">
    <div id="canvas"></div>
    <div id="stage"></div>
</div>

<script>
    const layout = [
        {
            path: "_DSF3464.jpg",
            type: "image/jpeg",
            visible: true,
            x: 50,
            y: 50,
            z: 2,
            w: 200,
        },
        {
            path: "_DSF2796.jpg",
            type: "image/jpeg",
            visible: true,
            x: 50,
            y: 300,
            z: 1,
            w: 200,
        }
    ]

    const largestZ = (layout) => Math.max(...layout.map(e => e.z || 0));

    const makeThumbnail = (data) => {
        const img = document.createElement("img");
        img.src = data.path;
        img.style.width = "90%";
        img.style.padding = "10px";

        const div = document.createElement("div");
        div.appendChild(img)

        const mouseDown = (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Duplicate data
            let dup = {
                ...data,
                visible: true,
                x: 20, 
                y: 20,
                z: largestZ(layout) + 1,
                w: 200,
            }
            layout.push(dup);
            let div = createCanvasElement(dup);
            document.getElementById('canvas').appendChild(div);
        }

        div.addEventListener('mousedown', mouseDown);
        return div;
    }

    const createCanvasElement = (data) => {
        let [x, y] = [data.x, data.y];

        let elem;
        if (["image/jpeg", "image/png"].includes(data.type)) {
            elem = document.createElement("img");
            elem.src = data.path;
            elem.width = data.w;
        }


        const div = document.createElement("div");
        div.style.position = 'absolute';
        div.style.left = data.x;
        div.style.top = data.y;
        div.style.zIndex = data.z;
        div.appendChild(elem);

        // Store reference for easy access
        data.canvasElem = div;

        const mouseDown = (e) => {
            e.preventDefault();
            e.stopPropagation(); // Don't call parent's mouseDown

            [x, y] = [e.clientX, e.clientY];

            // Pop to front
            const z = largestZ(layout);
            div.style.zIndex = z + 1
            data.z = z + 1;

            document.addEventListener('mousemove', mouseMove);
            document.addEventListener('mouseup', mouseUp);
        }

        const mouseMove = (e) => {
            const [dx, dy] = [e.clientX - x, e.clientY - y];

            div.style.left = dx + parseInt(div.style.left.slice(0, -2));
            div.style.top = dy + parseInt(div.style.top.slice(0, -2));

            [x, y] = [e.clientX, e.clientY];
        }

        const mouseUp = () => {
            document.removeEventListener('mousemove', mouseMove);
            document.removeEventListener('mouseup', mouseUp);
        }

        div.addEventListener('mousedown', mouseDown);
        return div;
    }

    const makeCanvasInfinite = (canvas) => {
        let x, y;

        const mouseDown = (e) => {
            e.preventDefault();
            e.stopPropagation();

            [x, y] = [e.clientX, e.clientY];

            document.addEventListener('mousemove', mouseMove);
            document.addEventListener('mouseup', mouseUp);
        }

        const mouseMove = (e) => {
            const [dx, dy] = [e.clientX - x, e.clientY - y];

            layout.map(d => {
                if (d.visible) {
                    let currX = parseInt(d.canvasElem.style.left.slice(0, -2));
                    let currY = parseInt(d.canvasElem.style.top.slice(0, -2));
                    d.canvasElem.style.left = currX + Math.floor(dx / 10);
                    d.canvasElem.style.top = currY + Math.floor(dy / 10);
                }
            })

            [x, y] = [e.clientX, e.clientY];
        }

        const mouseUp = () => {
            document.removeEventListener('mousemove', mouseMove);
            document.removeEventListener('mouseup', mouseUp);
        }

        canvas.addEventListener('mousedown', mouseDown);
    }

    var ws = new WebSocket("ws://localhost:1234/ws");
    ws.onmessage = e => {
        const files = JSON.parse(e.data);

        const stage = document.getElementById("stage");
        const canvas = document.getElementById("canvas");

        makeCanvasInfinite(canvas);

        files.map(d => {
            let data = {
                path: d.path,
                type: d.type,
                visible: false,
            }
            layout.push(data);
            stage.appendChild(makeThumbnail(data));
        })

        layout.filter(d => d.visible)
            .map(createCanvasElement)
            .map(e => canvas.appendChild(e));
    }
    ws.onopen = e => {
        ws.send("initialize");
    }
</script>
